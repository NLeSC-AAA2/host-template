#define R float
#define E R
#define stride int
#define INT int
#define K(x) ((E) x)
#define DK(name,value) const E name = K(value)
#define WS(s,i) s*i
#define MAKE_VOLATILE_STRIDE(x,y) 0
#define FMA(a,b,c) a * b + c
#define FMS(a,b,c) a * b - c
#define FNMA(a,b,c) -a * b - c
#define FNMS(a,b,c) -a * b + c

__constant float w_4_4[24] = {
  1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.9238795325112867, 0.3826834323650898,
    0.7071067811865476, 0.7071067811865475, 0.38268343236508984,
    0.9238795325112867, 0.7071067811865476, 0.7071067811865475,
    6.123233995736766e-17, 1.0, -0.7071067811865475, 0.7071067811865476,
    0.38268343236508984, 0.9238795325112867, -0.7071067811865475,
    0.7071067811865476, -0.9238795325112868, -0.38268343236508967
};

/* Generated by: ./genfft/gen_twiddle.native -n 4 -name twiddle_4 -compact -standalone -opencl */

/*
 * This function contains 22 FP additions, 12 FP multiplications,
 * (or, 16 additions, 6 multiplications, 6 fused multiply/add),
 * 13 stack variables, 0 constants, and 16 memory accesses
 */
void
twiddle_4 (R * ri, R * ii, __constant const R * W, stride rs, INT mb, INT me,
           INT ms)
{
  {
    INT m;
    for (m = mb, W = W + (mb * 6); m < me;
         m = m + 1, ri = ri + ms, ii = ii + ms, W =
         W + 6, MAKE_VOLATILE_STRIDE (8, rs))
      {
        E T1, Tp, T6, To, Tc, Tk, Th, Tl;
        T1 = ri[0];
        Tp = ii[0];
        {
          E T3, T5, T2, T4;
          T3 = ri[WS (rs, 2)];
          T5 = ii[WS (rs, 2)];
          T2 = W[2];
          T4 = W[3];
          T6 = FMA (T2, T3, T4 * T5);
          To = FNMS (T4, T3, T2 * T5);
        }
        {
          E T9, Tb, T8, Ta;
          T9 = ri[WS (rs, 1)];
          Tb = ii[WS (rs, 1)];
          T8 = W[0];
          Ta = W[1];
          Tc = FMA (T8, T9, Ta * Tb);
          Tk = FNMS (Ta, T9, T8 * Tb);
        }
        {
          E Te, Tg, Td, Tf;
          Te = ri[WS (rs, 3)];
          Tg = ii[WS (rs, 3)];
          Td = W[4];
          Tf = W[5];
          Th = FMA (Td, Te, Tf * Tg);
          Tl = FNMS (Tf, Te, Td * Tg);
        }
        {
          E T7, Ti, Tn, Tq;
          T7 = T1 + T6;
          Ti = Tc + Th;
          ri[WS (rs, 2)] = T7 - Ti;
          ri[0] = T7 + Ti;
          Tn = Tk + Tl;
          Tq = To + Tp;
          ii[0] = Tn + Tq;
          ii[WS (rs, 2)] = Tq - Tn;
        }
        {
          E Tj, Tm, Tr, Ts;
          Tj = T1 - T6;
          Tm = Tk - Tl;
          ri[WS (rs, 3)] = Tj - Tm;
          ri[WS (rs, 1)] = Tj + Tm;
          Tr = Tp - To;
          Ts = Tc - Th;
          ii[WS (rs, 1)] = Tr - Ts;
          ii[WS (rs, 3)] = Ts + Tr;
        }
      }
  }
}

/* Generated by: ./genfft/gen_notw.native -n 4 -name notw_4 -compact -standalone -opencl */

/*
 * This function contains 16 FP additions, 0 FP multiplications,
 * (or, 16 additions, 0 multiplications, 0 fused multiply/add),
 * 13 stack variables, 0 constants, and 16 memory accesses
 */
void
notw_4 (const R * ri, const R * ii, R * ro, R * io, stride is, stride os,
        INT v, INT ivs, INT ovs)
{
  {
    INT i;
    for (i = v; i > 0;
         i = i - 1, ri = ri + ivs, ii = ii + ivs, ro = ro + ovs, io =
         io + ovs, MAKE_VOLATILE_STRIDE (16, is), MAKE_VOLATILE_STRIDE (16,
                                                                        os))
      {
        E T3, Tb, T9, Tf, T6, Ta, Te, Tg;
        {
          E T1, T2, T7, T8;
          T1 = ri[0];
          T2 = ri[WS (is, 2)];
          T3 = T1 + T2;
          Tb = T1 - T2;
          T7 = ii[0];
          T8 = ii[WS (is, 2)];
          T9 = T7 - T8;
          Tf = T7 + T8;
        }
        {
          E T4, T5, Tc, Td;
          T4 = ri[WS (is, 1)];
          T5 = ri[WS (is, 3)];
          T6 = T4 + T5;
          Ta = T4 - T5;
          Tc = ii[WS (is, 1)];
          Td = ii[WS (is, 3)];
          Te = Tc - Td;
          Tg = Tc + Td;
        }
        ro[WS (os, 2)] = T3 - T6;
        io[WS (os, 2)] = Tf - Tg;
        ro[0] = T3 + T6;
        io[0] = Tf + Tg;
        io[WS (os, 1)] = T9 - Ta;
        ro[WS (os, 1)] = Tb + Te;
        io[WS (os, 3)] = Ta + T9;
        ro[WS (os, 3)] = Tb - Te;
      }
  }
}

void fft_16(float const *input, float *output) {
    notw_4(input, input + 1, output, output + 1, 8, 2, 4, 2, 8);
    twiddle_4(output, output + 1, w_4_4, 8, 0, 4, 2);
}
