#pragma OPENCL EXTENSION cl_intel_channels : enable

#include <ihc_apint.h>

channel float2 in_channel, out_channel;

#define R float
#define E R
#define stride int
#define INT int
#define K(x) ((E) x)
#define DK(name,value) const E name = K(value)
#define WS(s,i) s*i
#define MAKE_VOLATILE_STRIDE(x,y) 0
#define FMA(a,b,c) a * b + c
#define FMS(a,b,c) a * b - c
#define FNMA(a,b,c) -a * b - c
#define FNMS(a,b,c) -a * b + c

/* Generated by: ./genfft/gen_notw.native -n 5 -name notw_5 -compact -standalone */

/*
 * This function contains 32 FP additions, 12 FP multiplications,
 * (or, 26 additions, 6 multiplications, 6 fused multiply/add),
 * 21 stack variables, 4 constants, and 20 memory accesses
 */
void
notw_5 (const R * ri, const R * ii, R * ro, R * io, stride is, stride os)
{
  DK (KP250000000, +0.250000000000000000000000000000000000000000000);
  DK (KP587785252, +0.587785252292473129168705954639072768597652438);
  DK (KP951056516, +0.951056516295153572116439333379382143405698634);
  DK (KP559016994, +0.559016994374947424102293417182819058860154590);
  {
    E T1, To, T8, Tt, T9, Ts, Te, Tp, Th, Tn;
    T1 = ri[0];
    To = ii[0];
    {
      E T2, T3, T4, T5, T6, T7;
      T2 = ri[WS (is, 1)];
      T3 = ri[WS (is, 4)];
      T4 = T2 + T3;
      T5 = ri[WS (is, 2)];
      T6 = ri[WS (is, 3)];
      T7 = T5 + T6;
      T8 = T4 + T7;
      Tt = T5 - T6;
      T9 = KP559016994 * (T4 - T7);
      Ts = T2 - T3;
    }
    {
      E Tc, Td, Tl, Tf, Tg, Tm;
      Tc = ii[WS (is, 1)];
      Td = ii[WS (is, 4)];
      Tl = Tc + Td;
      Tf = ii[WS (is, 2)];
      Tg = ii[WS (is, 3)];
      Tm = Tf + Tg;
      Te = Tc - Td;
      Tp = Tl + Tm;
      Th = Tf - Tg;
      Tn = KP559016994 * (Tl - Tm);
    }
    ro[0] = T1 + T8;
    io[0] = To + Tp;
    {
      E Ti, Tk, Tb, Tj, Ta;
      Ti = FMA (KP951056516, Te, KP587785252 * Th);
      Tk = FNMS (KP587785252, Te, KP951056516 * Th);
      Ta = FNMS (KP250000000, T8, T1);
      Tb = T9 + Ta;
      Tj = Ta - T9;
      ro[WS (os, 4)] = Tb - Ti;
      ro[WS (os, 3)] = Tj + Tk;
      ro[WS (os, 1)] = Tb + Ti;
      ro[WS (os, 2)] = Tj - Tk;
    }
    {
      E Tu, Tv, Tr, Tw, Tq;
      Tu = FMA (KP951056516, Ts, KP587785252 * Tt);
      Tv = FNMS (KP587785252, Ts, KP951056516 * Tt);
      Tq = FNMS (KP250000000, Tp, To);
      Tr = Tn + Tq;
      Tw = Tq - Tn;
      io[WS (os, 1)] = Tr - Tu;
      io[WS (os, 3)] = Tw - Tv;
      io[WS (os, 4)] = Tu + Tr;
      io[WS (os, 2)] = Tv + Tw;
    }
  }
}

__kernel
__attribute__((autorun))
__attribute__((max_global_work_dim(0)))
void do_fft_5()
{
    float ai[5], ar[5], bi[5], br[5];
    for (int n = 0; n < 5; n ++) {
        float2 a = read_channel_intel(in_channel);
	    ar[n] = a.x;
        ai[n] = a.y;
    }
    notw_5(ar, ai, br, bi, 1, 1);
    for (int n = 0; n < 5; n ++) {
	    float2 b;
        b.x = br[n];
        b.y = bi[n];
        write_channel_intel(out_channel, b);
    }
}

__attribute__((max_global_work_dim(0)))
__kernel void source(__global const volatile float2 *in, unsigned count)
{
  for (unsigned i = 0; i < count; i ++)
    write_channel_intel(in_channel, in[i]);
}

__attribute__((max_global_work_dim(0)))
__kernel void sink(__global float2 *out, unsigned count)
{
  for (unsigned i = 0; i < count; i ++)
    out[i] = read_channel_intel(out_channel);
}

// vim:ft=c
