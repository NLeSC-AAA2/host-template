#pragma OPENCL EXTENSION cl_intel_channels : enable

#include <ihc_apint.h>

channel float2 in_channel, out_channel;

#define R float
#define E R
#define stride int
#define INT int
#define K(x) ((E) x)
#define DK(name,value) const E name = K(value)
#define WS(s,i) s*i
#define MAKE_VOLATILE_STRIDE(x,y) 0
#define FMA(a,b,c) a * b + c
#define FMS(a,b,c) a * b - c
#define FNMA(a,b,c) -a * b - c
#define FNMS(a,b,c) -a * b + c

__constant float w_5_2[10] = {
  1.0, 0.0, 0.8090169943749475, 0.5877852522924731, 0.30901699437494745,
    0.9510565162951535, -0.30901699437494734, 0.9510565162951536,
    -0.8090169943749473, 0.5877852522924732
}

__constant float w_10_2[20] = {
  1.0, 0.0, 0.9510565162951535, 0.3090169943749474, 0.8090169943749475,
    0.5877852522924731, 0.5877852522924731, 0.8090169943749475,
    0.30901699437494745, 0.9510565162951535, 6.123233995736766e-17, 1.0,
    -0.30901699437494734, 0.9510565162951536, -0.587785252292473,
    0.8090169943749475, -0.8090169943749473, 0.5877852522924732,
    -0.9510565162951535, 0.3090169943749475
}

/* Generated by: ./genfft/gen_twiddle.native -n 2 -name twiddle_2 -compact -standalone */

/*
 * This function contains 6 FP additions, 4 FP multiplications,
 * (or, 4 additions, 2 multiplications, 2 fused multiply/add),
 * 9 stack variables, 0 constants, and 8 memory accesses
 */
void
twiddle_2 (R * ri, R * ii, const R * W, stride rs, INT mb, INT me, INT ms)
{
  {
    INT m;
    for (m = mb, W = W + (mb * 2); m < me;
         m = m + 1, ri = ri + ms, ii = ii + ms, W =
         W + 2, MAKE_VOLATILE_STRIDE (4, rs))
      {
        E T1, T8, T6, T7;
        T1 = ri[0];
        T8 = ii[0];
        {
          E T3, T5, T2, T4;
          T3 = ri[WS (rs, 1)];
          T5 = ii[WS (rs, 1)];
          T2 = W[0];
          T4 = W[1];
          T6 = FMA (T2, T3, T4 * T5);
          T7 = FNMS (T4, T3, T2 * T5);
        }
        ri[WS (rs, 1)] = T1 - T6;
        ii[WS (rs, 1)] = T8 - T7;
        ri[0] = T1 + T6;
        ii[0] = T7 + T8;
      }
  }
}

/* Generated by: ./genfft/gen_notw.native -n 5 -name notw_5 -compact -standalone */

/*
 * This function contains 32 FP additions, 12 FP multiplications,
 * (or, 26 additions, 6 multiplications, 6 fused multiply/add),
 * 21 stack variables, 4 constants, and 20 memory accesses
 */
void
notw_5 (const R * ri, const R * ii, R * ro, R * io, stride is, stride os,
        INT v, INT ivs, INT ovs)
{
  DK (KP250000000, +0.250000000000000000000000000000000000000000000);
  DK (KP587785252, +0.587785252292473129168705954639072768597652438);
  DK (KP951056516, +0.951056516295153572116439333379382143405698634);
  DK (KP559016994, +0.559016994374947424102293417182819058860154590);
  {
    INT i;
    for (i = v; i > 0;
         i = i - 1, ri = ri + ivs, ii = ii + ivs, ro = ro + ovs, io =
         io + ovs, MAKE_VOLATILE_STRIDE (20, is), MAKE_VOLATILE_STRIDE (20,
                                                                        os))
      {
        E T1, To, T8, Tt, T9, Ts, Te, Tp, Th, Tn;
        T1 = ri[0];
        To = ii[0];
        {
          E T2, T3, T4, T5, T6, T7;
          T2 = ri[WS (is, 1)];
          T3 = ri[WS (is, 4)];
          T4 = T2 + T3;
          T5 = ri[WS (is, 2)];
          T6 = ri[WS (is, 3)];
          T7 = T5 + T6;
          T8 = T4 + T7;
          Tt = T5 - T6;
          T9 = KP559016994 * (T4 - T7);
          Ts = T2 - T3;
        }
        {
          E Tc, Td, Tl, Tf, Tg, Tm;
          Tc = ii[WS (is, 1)];
          Td = ii[WS (is, 4)];
          Tl = Tc + Td;
          Tf = ii[WS (is, 2)];
          Tg = ii[WS (is, 3)];
          Tm = Tf + Tg;
          Te = Tc - Td;
          Tp = Tl + Tm;
          Th = Tf - Tg;
          Tn = KP559016994 * (Tl - Tm);
        }
        ro[0] = T1 + T8;
        io[0] = To + Tp;
        {
          E Ti, Tk, Tb, Tj, Ta;
          Ti = FMA (KP951056516, Te, KP587785252 * Th);
          Tk = FNMS (KP587785252, Te, KP951056516 * Th);
          Ta = FNMS (KP250000000, T8, T1);
          Tb = T9 + Ta;
          Tj = Ta - T9;
          ro[WS (os, 4)] = Tb - Ti;
          ro[WS (os, 3)] = Tj + Tk;
          ro[WS (os, 1)] = Tb + Ti;
          ro[WS (os, 2)] = Tj - Tk;
        }
        {
          E Tu, Tv, Tr, Tw, Tq;
          Tu = FMA (KP951056516, Ts, KP587785252 * Tt);
          Tv = FNMS (KP587785252, Ts, KP951056516 * Tt);
          Tq = FNMS (KP250000000, Tp, To);
          Tr = Tn + Tq;
          Tw = Tq - Tn;
          io[WS (os, 1)] = Tr - Tu;
          io[WS (os, 3)] = Tw - Tv;
          io[WS (os, 4)] = Tu + Tr;
          io[WS (os, 2)] = Tv + Tw;
        }
      }
  }
}

void fft_20(float const *input, float *output) {
    notw_5(input, input + 1, output, output + 1, 4, 1, 2, 2, 5);
    twiddle_2(output, output + 1, w_5_2, 5, 0, 5, 1);
    notw_5(input + 2, input + 3, output + 20, output + 21, 4, 1, 2, 2, 5);
    twiddle_2(output + 20, output + 21, w_5_2, 5, 0, 5, 1);
    twiddle_2(output, output + 1, w_10_2, 10, 0, 10, 1);
}

__kernel
__attribute__((autorun))
__attribute__((max_global_work_dim(0)))
void do_fft_20()
{
    float2 a[20], b[20];
    for (int n = 0; n < 20; n ++)
	    a[n][i] = read_channel_intel(in_channel);
    fft_20(a, b);
    for (int n = 0; n < 20; n ++)
	    write_channel_intel(out_channel, a[n]);  
}

__attribute__((max_global_work_dim(0)))
__kernel void source(__global const volatile float2 *in, unsigned count)
{
  for (unsigned i = 0; i < count; i ++)
    write_channel_intel(in_channel, in[i]);
}

__attribute__((max_global_work_dim(0)))
__kernel void sink(__global float2 *out, unsigned count)
{
  for (unsigned i = 0; i < count; i ++)
    out[i] = read_channel_intel(out_channel);
}

// vim:ft=c
